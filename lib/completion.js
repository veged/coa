// Generated by CoffeeScript 1.4.0
/**
Most of the code adopted from the npm package shell completion code.
See https://github.com/isaacs/npm/blob/master/lib/completion.js
*/

var Q, complete, dumpScript, escape, findOpt, getOpts, isOpt, unescape;

Q = require('q');

escape = require('./shell').escape;

unescape = require('./shell').unescape;

module.exports = function() {
  return this.title('Shell completion').helpful().arg().name('raw').title('Completion words').arr().end().act(function(opts, args) {
    var argv, cmd, e, _ref;
    if (process.platform === 'win32') {
      e = new Error('shell completion not supported on windows');
      e.code = 'ENOTSUP';
      e.errno = require('constants').ENOTSUP;
      return this.reject(e);
    }
    if (!(process.env.COMP_CWORD != null) || !(process.env.COMP_LINE != null) || !(process.env.COMP_POINT != null)) {
      return dumpScript(this._cmd._name);
    }
    console.error('---------');
    console.error('COMP_LINE:  %s', process.env.COMP_LINE);
    console.error('COMP_CWORD: %s', process.env.COMP_CWORD);
    console.error('COMP_POINT: %s', process.env.COMP_POINT);
    console.error('args: %j', args.raw);
    opts = getOpts(args.raw);
    _ref = this._cmd._parseCmd(opts.partialWords), cmd = _ref.cmd, argv = _ref.argv;
    return Q.when(complete(cmd, opts), function(compls) {
      return console.log(compls.map(escape).join('\n'));
    });
  });
};

dumpScript = function(name) {
  var defer, fs, path;
  fs = require('fs');
  path = require('path');
  defer = Q.defer();
  fs.readFile(path.resolve(__dirname, 'completion.sh'), 'utf8', function(err, d) {
    var onError;
    if (err) {
      return defer.reject(err);
    }
    d = d.replace(/{{cmd}}/g, path.basename(name)).replace(/^\#\!.*?\n/, '');
    onError = function(err) {
      if (err.errno === require('constants').EPIPE) {
        process.stdout.removeListener('error', onError);
        return defer.resolve();
      } else {
        return defer.reject(err);
      }
    };
    process.stdout.on('error', onError);
    return process.stdout.write(d, function() {
      return defer.resolve();
    });
  });
  return defer.promise;
};

getOpts = function(argv) {
  var i, line, partialLine, partialWord, partialWords, point, w, word, words;
  line = process.env.COMP_LINE;
  w = +process.env.COMP_CWORD;
  point = +process.env.COMP_POINT;
  words = argv.map(unescape);
  word = words[w];
  partialLine = line.substr(0, point);
  partialWords = words.slice(0, w);
  partialWord = argv[w] || '';
  i = partialWord.length;
  while (partialWord.substr(0, i) !== partialLine.substr(-1 * i) && i > 0) {
    i--;
  }
  partialWord = unescape(partialWord.substr(0, i));
  if (partialWord) {
    partialWords.push(partialWord);
  }
  return {
    line: line,
    w: w,
    point: point,
    words: words,
    word: word,
    partialLine: partialLine,
    partialWords: partialWords,
    partialWord: partialWord
  };
};

isOpt = function(p) {
  return p.indexOf('-') === 0;
};

findOpt = function(parts) {
  var p, _i, _len;
  for (_i = 0, _len = parts.length; _i < _len; _i++) {
    p = parts[_i];
    if (isOpt(p)) {
      return true;
    }
  }
  return false;
};

complete = function(cmd, opts) {
  var addCompls, completeCmd, completeCustom, completeOpt, completeOptValue, compls, filterCompls, hasOpts, isPartialOpt, isPrevOpt, m, opt, optWord, partial, prev;
  compls = [];
  partial = opts.partialWord;
  prev = opts.partialWords[opts.w - 1];
  isPartialOpt = isOpt(partial);
  isPrevOpt = isOpt(prev);
  hasOpts = findOpt(opts.partialWords);
  addCompls = function(c) {
    return compls.push(c);
  };
  filterCompls = function(compls) {
    return (compls || []).filter(function(c) {
      return partial === '' || c.indexOf(partial) === 0;
    });
  };
  completeCmd = function(cmd) {
    if (!hasOpts) {
      return filterCompls(Object.keys(cmd._cmdsByName || []));
    } else {
      return [];
    }
  };
  completeOpt = function(cmd) {
    return filterCompls(Object.keys(cmd._optsByKey || []));
  };
  completeOptValue = function(opt, prefix, p) {
    var newOpts;
    if (prefix == null) {
      prefix = '';
    }
    if (p == null) {
      p = partial;
    }
    if (opt._comp) {
      newOpts = Object.create(opts, {
        partialWord: {
          value: p
        }
      });
      return Q.when(opt._comp(newOpts), function(o) {
        return filterCompls(o.map(function(v) {
          return prefix + v;
        }));
      });
    } else {
      return [];
    }
  };
  completeCustom = function(cmd) {
    if (cmd._comp) {
      return Q.when(cmd._comp(opts), filterCompls);
    } else {
      return [];
    }
  };
  if (!isPartialOpt) {
    if (isPrevOpt && (opt = cmd._optsByKey[prev])) {
      if (opt._flag) {
        if (!opt._only) {
          addCompls(completeOpt(cmd));
          completeCustom(cmd);
        }
      } else {
        addCompls(completeOptValue(opt));
      }
    } else {
      addCompls(completeCmd(cmd));
      addCompls(completeOpt(cmd));
      completeCustom(cmd);
    }
  } else {
    if (!isPrevOpt || ((opt = cmd._optsByKey[prev]) && opt._flag)) {
      if (m = partial.match(/^(--\w[\w\-_]*)=(.*)$/)) {
        optWord = m[1];
        if ((opt = cmd._optsByKey[optWord]) && !opt._flag) {
          addCompls(completeOptValue(opt, optWord + '=', m[2]));
        }
      } else if (!opt || !opt._only) {
        addCompls(completeOpt(cmd));
      }
    }
  }
  return Q.all(compls).then(function(all) {
    var one, _i, _len;
    compls = [];
    for (_i = 0, _len = all.length; _i < _len; _i++) {
      one = all[_i];
      compls = compls.concat(one);
    }
    console.error('partial: %s', partial);
    console.error('compls: %j', compls);
    return compls;
  });
};
